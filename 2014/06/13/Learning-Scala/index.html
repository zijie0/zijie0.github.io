
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Learning Scala | Tada!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Zijie0">
    
    <meta name="description" itemprop="description" content="Coursera Scala课程学习笔记。">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Tada!" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Tada!" title="Tada!"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Tada!">Tada!</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Main</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/06/13/Learning-Scala/" title="Learning Scala" itemprop="url">Learning Scala</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://zijie0.github.io/about" title="Zijie0" target="_blank" itemprop="author">Zijie0</a>
		
  <p class="article-time">
    <time datetime="2014-06-13T02:09:24.000Z" itemprop="datePublished"> Published Jun 13 2014</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#寒暄"><span class="toc-number">1.</span> <span class="toc-text">寒暄</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正文"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#环境准备"><span class="toc-number">2.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REPL"><span class="toc-number">2.2.</span> <span class="toc-text">REPL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Evaluation_Rules"><span class="toc-number">2.3.</span> <span class="toc-text">Evaluation Rules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归与尾递归"><span class="toc-number">2.4.</span> <span class="toc-text">递归与尾递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#High_order_functions"><span class="toc-number">2.5.</span> <span class="toc-text">High order functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Currying"><span class="toc-number">2.6.</span> <span class="toc-text">Currying</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Classes"><span class="toc-number">2.7.</span> <span class="toc-text">Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class_Hierarchies"><span class="toc-number">2.8.</span> <span class="toc-text">Class Hierarchies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class_Organization"><span class="toc-number">2.9.</span> <span class="toc-text">Class Organization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Polymorphism"><span class="toc-number">2.10.</span> <span class="toc-text">Polymorphism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pattern_Matching"><span class="toc-number">2.11.</span> <span class="toc-text">Pattern Matching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections"><span class="toc-number">2.12.</span> <span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ordering"><span class="toc-number">2.13.</span> <span class="toc-text">Ordering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#For-Comprehensions"><span class="toc-number">2.14.</span> <span class="toc-text">For-Comprehensions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream_and_Lazy_Evaluation"><span class="toc-number">2.15.</span> <span class="toc-text">Stream and Lazy Evaluation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作业"><span class="toc-number">3.</span> <span class="toc-text">作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FuncSet"><span class="toc-number">3.1.</span> <span class="toc-text">FuncSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Huffman_Code"><span class="toc-number">3.2.</span> <span class="toc-text">Huffman Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bloxorz"><span class="toc-number">3.3.</span> <span class="toc-text">Bloxorz</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终于写完了"><span class="toc-number">4.</span> <span class="toc-text">终于写完了</span></a></li></ol>
		
		</div>
		
		<h2 id="寒暄">寒暄</h2>
<p>昨天刚完成了Coursera上Scala课程的最后一周作业，十分激动兴奋！这门课由Scala的作者Martin Odersky亲自教授，展示了不少Scala尤其是应用函数式编程的最佳实践。学完有个最大的感受就是这门语言真的是非常复杂灵活，不知道跟C++相比如何（完全没学过C++）。每次做作业都会觉得可以实现的方式太多了（如果没有给出框架的话……），各种语法糖也是令人眼花缭乱，比起Perl，Ruby来真是有过之而无不及啊！如果光从教授函数式编程的方面来看，这门课跟Dan Grossman的<a href="https://www.coursera.org/course/proglang" target="_blank" rel="external">Programming Language</a>还是有点距离的，后者的讲解真是系统详尽，娓娓道来，让人回味无穷啊！</p>
<p>Scala这门课的讲课内容不多，很多作业练习据作者说是借鉴了神书<a href="http://mitpress.mit.edu/sicp/full-text/book/book.html" target="_blank" rel="external">SICP</a>的，感觉的确还挺有趣的！为了加深理解，巩固记忆，就在这里略微总结一下知识点把！</p>
<h2 id="正文">正文</h2>
<h3 id="环境准备">环境准备</h3>
<p>第一周先介绍了Scala环境的安装准备，整个课程基本都是用sbt（类似maven）来构建项目，自动提交作业的，所以也没了解过不用sbt要怎么搞……sbt的具体介绍可以看<a href="https://github.com/CSUG/real_world_scala/blob/master/02_sbt.markdown" target="_blank" rel="external">这里</a>。</p>
<p>IDE的话老师推荐的是Eclipse，不过出于对IntelliJ的疯狂热爱，我还是选了IntelliJ + Scala plugin，跟老师视频演示对比了下感觉成熟稳定性暂时还不及Eclipse，经常有些诡异的小问题，比如在worksheet里加package名限定的话evaluate时候输出直接是空白的……还有很多地方提示语法有问题，但是编译运行都可以通过……感觉Eclipse的Scala插件应该是亲生的，会比较靠谱些。</p>
<h3 id="REPL">REPL</h3>
<p>貌似现代语言没个REPL环境都不好意思出来混啊，Scala里也自带了REPL，直接敲Scala回车即可。不过我基本没怎么用过它，因为Scala里有更加牛逼的worksheet，也就是Swift里面的playground哈哈！另外有个IDE叫LightTable也附带了这个功能，在使用Clojure时表现良好，值得推荐！有了worksheet，实时编写实时显示结果，调试代码的确轻松愉快很多啊！</p>
<h3 id="Evaluation_Rules">Evaluation Rules</h3>
<p>Scala里默认用的是Call by value，另外一种是Call by name，有点像Haskell里的lazy evaluation，不知道怎么具体翻译，就给个例子吧：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> first(x: Int, y: Int) = x</div></pre></td></tr></table></figure>


<p>一个简单的函数，直接返回第一个参数。值得注意的是Scala里的变量类型是放在后面的，跟Go和Swift一样哈哈。然后我们调用它：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">first(<span class="number">1</span>, loop)</div></pre></td></tr></table></figure>


<p>这里<code>loop</code>是个无限循环，如果是默认的Call by value，Scala会先把每一个参数的value算出来再执行函数后面的代码逻辑，所以哪怕函数并没有用到第二个参数，这个调用还是会进入死循环。不过Scala的灵活牛逼之处立马就开始展现了，我们可以改写这个函数成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> first(x: Int, y: =&gt; Int) = x</div></pre></td></tr></table></figure>


<p>加了一个<code>=&gt;</code>符号，这个参数立刻就成了Call by name，这样只有在用到它的时候才会去evaluate，哪怕是个无限循环也照样可以跑啦！这个技巧在之后讲到Streams时还会用到。</p>
<h3 id="递归与尾递归">递归与尾递归</h3>
<p>这个大家应该都知道吧，用递归的确能写出一些很漂亮的代码来……大多数例子都是阶乘，Fib函数之类，课程中用了个牛顿法算开方的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sqrt(x: Double) = {</div><div class="line">  <span class="keyword">def</span> sqrtIter(guess: Double): Double =</div><div class="line">    <span class="keyword">if</span> (isGoodEnough(guess)) guess</div><div class="line">    <span class="keyword">else</span> sqrtIter(improve(guess))</div><div class="line"> </div><div class="line">  <span class="keyword">def</span> isGoodEnough(guess: Double): Boolean =</div><div class="line">    math.abs(guess * guess - x) / x &lt; <span class="number">0.001</span></div><div class="line"> </div><div class="line">  <span class="keyword">def</span> improve(guess: Double): Double =</div><div class="line">    (guess + x / guess) / <span class="number">2</span></div><div class="line">  sqrtIter(<span class="number">1.0</span>)</div><div class="line">}</div></pre></td></tr></table></figure>


<p>很直观吧！不过递归如果层数过深可能导致stack overflow的问题，所以就有了尾递归优化，比如这个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> gcd(a: Int, b: Int): Int =</div><div class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) a <span class="keyword">else</span> gcd(b, a % b)</div></pre></td></tr></table></figure>


<p>这里进入if判断后如果条件不成立，就直接转到了函数本身的调用<code>gcd(b, a % b)</code>，相当于变成了一个等价的调用而不需要在stack上保留其它变量的信息，这样就可以重用这个stack了。但另一种常见的递归形式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> factorial(n: Int): Int =</div><div class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</div></pre></td></tr></table></figure>


<p>假设调用个<code>factorial(4)</code>，它需要一层一层展开直到<code>4*(3*(2*(1*factorial(0))) -&gt; 4*(3*(2*(1*1)))</code>，每一层stack都要储存那个n的值等到下一层的函数返回后再做具体计算，所以就不能重用stack了！所以我们可以尽量对需要做层数很深的递归的函数进行优化改写成尾递归或者直接改成循环来做。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> fact(n: Int): Int = {</div><div class="line">  <span class="keyword">def</span> loop(acc: Int, n: Int): Int = {</div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) acc</div><div class="line">    <span class="keyword">else</span> loop(acc * n, n - <span class="number">1</span>)</div><div class="line">  }</div><div class="line">  loop(<span class="number">1</span>, n)</div><div class="line">}</div></pre></td></tr></table></figure>


<p>Like this!用一个acc来存储中间结果并传到下一层去，算是个常用方法吧。另外Scala中还可以用<code>@tailrec</code>来指定函数必须为尾递归，否则会在编译时报错。</p>
<h3 id="High_order_functions">High order functions</h3>
<p>这应该是FP里最著名的概念了吧。大致就是可以在一个函数里返回一个函数，也可以把函数作为参数传入一个函数……看看代码比较直观：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sum_tr(f: Int =&gt; Int, a: Int, b: Int): Int = {</div><div class="line">  <span class="keyword">def</span> loop(a: Int, acc: Int): Int = {</div><div class="line">    <span class="keyword">if</span> (a &gt; b) acc</div><div class="line">    <span class="keyword">else</span> loop(a + <span class="number">1</span>, acc + f(a))</div><div class="line">  }</div><div class="line">  loop(a, <span class="number">0</span>)</div><div class="line">}</div></pre></td></tr></table></figure>


<p>直接放了尾递归的版本，这个函数接受3个参数，第一个是一个输入一个Int返回一个Int的函数，后面a和b是sum的范围，比如从5累加到10之类。如果我们需要直接做累加，可以这样调用：<code>sum(x =&gt; x, a, b)</code>，如果要算立方和，就可以改成<code>sum(x =&gt; x * x * x, a, b)</code>，方便，优雅，高逼格！</p>
<h3 id="Currying">Currying</h3>
<p>又是一个很著名的概念，名字来源于Haskell Curry大神……我要是成了大神是不是也能像他那样名和姓还能分别来命名程序语言和编程技术……Currying，顾名思义，就是采用了这种牛逼的技术后的代码，会让使用者在阅读和应用过程中感受到若有若无的咖喱香，其中以青咖喱最为爽辣过瘾……好吧，正经点，传说中编程语言的函数在一开始都是只能接受单个参数的，那要传多个参数怎么办呢？那就传一个参数，返回一个函数，然后再传一个，再返回一个函数，and so on……比如还是我们的老朋友sum函数，现在它将披上咖喱的外衣……</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sum_c(f: Int =&gt; Int): (Int, Int) =&gt; Int = {</div><div class="line">  <span class="keyword">def</span> sumF(a: Int, b: Int): Int = {</div><div class="line">    <span class="keyword">if</span> (a &gt; b) <span class="number">0</span></div><div class="line">    <span class="keyword">else</span> f(a) + sumF(a + <span class="number">1</span>, b)</div><div class="line">  }</div><div class="line">  sumF</div><div class="line">}</div></pre></td></tr></table></figure>


<p>简化一下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sum(f: Int =&gt; Int)(a: Int, b: Int): Int = {</div><div class="line">  <span class="keyword">if</span> (a &gt; b) <span class="number">0</span> <span class="keyword">else</span> f(a) + sum(f)(a + <span class="number">1</span>, b)</div><div class="line">}</div></pre></td></tr></table></figure>


<p>我们还可以用这个方法来写连乘的!</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> product(f: Int =&gt; Int)(a: Int, b: Int): Int = {</div><div class="line">  <span class="keyword">if</span> (a &gt; b) <span class="number">1</span> <span class="keyword">else</span> f(a) * product(f)(a + <span class="number">1</span>, b)</div><div class="line">}</div></pre></td></tr></table></figure>


<p>写个咖喱版阶乘！</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> factorial(a: Int): Int = {</div><div class="line">  product(x =&gt; x)(<span class="number">1</span>, a)</div><div class="line">}</div></pre></td></tr></table></figure>


<p>就是这么简单！上面的<code>sum</code>和<code>product</code>长得很像，我们还可以提取一下共同点：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> mapReduce(f: Int =&gt; Int, combine:(Int, Int) =&gt; Int, zero: Int)(a: Int, b: Int): Int = {</div><div class="line">  <span class="keyword">if</span> (a &gt; b) zero</div><div class="line">  <span class="keyword">else</span> combine(f(a), mapReduce(f, combine, zero)(a + <span class="number">1</span>, b))</div><div class="line">}</div></pre></td></tr></table></figure>


<p>于是就有了神奇的map-reduce！感觉我可以给这篇文章加上一个big-data的tag了有没有！<br>用新鲜火烫的<code>mapReduce</code>表达一下我们激动的心情：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> excitingProduct(f: Int =&gt; Int)(a: Int, b: Int): Int = {</div><div class="line">  mapReduce(f, (x, y) =&gt; x * y, <span class="number">1</span>)(a, b)</div><div class="line">}</div></pre></td></tr></table></figure>


<p>另外还有个跟Currying不太一样的组合函数方式<code>compose</code>，比如我们定义一个简单的取绝对值开方函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sqrt_of_abs(i: Int) = math.sqrt(intToDouble(math.abs(i)))</div></pre></td></tr></table></figure>


<p>这里是连续调用3个函数，我们可以直接把它们拼在一起！</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> sqrt_of_abs = math.sqrt _ compose intToDouble _ compose math.abs _</div></pre></td></tr></table></figure>


<p>还可以按apply的次序来组合：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> sqrt_of_abs = math.abs _ andThen intToDouble _ andThen math.sqrt _</div></pre></td></tr></table></figure>


<p>然后就可以直接调用<code>sqrt_of_abs(-9)</code>啦！</p>
<h3 id="Classes">Classes</h3>
<p>讲了半天FP，老师忽然来了个转折，开始介绍Scala中一些OO的概念，新一轮头脑风暴又开始了……类这个东西跟其他的OO语言还是挺像的，下面这个例子是实现一个有理数类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span><span class="params">(x: Int, y: Int)</span> </span>{</div><div class="line">  require(y != <span class="number">0</span>, <span class="string">"demoninator must be non-zero"</span>)</div><div class="line"> </div><div class="line">  <span class="keyword">def</span> <span class="keyword">this</span>(x: Int) = <span class="keyword">this</span>(x, <span class="number">1</span>)</div><div class="line"> </div><div class="line">  <span class="keyword">private</span> <span class="keyword">def</span> gcd(a: Int, b: Int): Int = <span class="keyword">if</span> (b == <span class="number">0</span>) a <span class="keyword">else</span> gcd(b, a % b)</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> g = gcd(x, y)</div><div class="line">  <span class="keyword">def</span> numer = x / g</div><div class="line">  <span class="keyword">def</span> denom = y / g</div><div class="line"> </div><div class="line">  <span class="keyword">def</span> + (that: Rational) = {</div><div class="line">    <span class="keyword">new</span> Rational(</div><div class="line">      numer * that.denom + that.numer * denom,</div><div class="line">      denom * that.denom</div><div class="line">    )</div><div class="line">  }</div><div class="line"> </div><div class="line">  <span class="keyword">def</span> unary_- : Rational = <span class="keyword">new</span> Rational(-numer, denom)</div><div class="line"> </div><div class="line">  <span class="keyword">def</span> - (that: Rational) = {</div><div class="line">    <span class="keyword">this</span> + -that</div><div class="line">  }</div><div class="line"> </div><div class="line">  <span class="keyword">def</span> * (that: Rational) = {</div><div class="line">    <span class="keyword">new</span> Rational(</div><div class="line">      numer * that.numer,</div><div class="line">      denom * that.denom</div><div class="line">    )</div><div class="line">  }</div><div class="line"> </div><div class="line">  <span class="keyword">def</span> &lt; (that: Rational) = numer * that.denom &lt; that.numer * denom</div><div class="line"> </div><div class="line">  <span class="keyword">def</span> max(that: Rational) = {</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> &lt; that) that <span class="keyword">else</span> <span class="keyword">this</span></div><div class="line">  }</div><div class="line"> </div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString = numer + <span class="string">"/"</span> + denom</div><div class="line">}</div></pre></td></tr></table></figure>


<p>这里唯一有点奇怪的就是那个unary了，<a href="http://stackoverflow.com/questions/16644988/why-is-the-unary-prefix-needed-in-scala" target="_blank" rel="external">这里</a>有一个关于为啥要用unary的解释！主要目的就是用它来实现一些前缀方法啦！（上例中是用它来表示负数）</p>
<h3 id="Class_Hierarchies">Class Hierarchies</h3>
<p>课上主要讲了abstract class，感觉跟别的语言里的抽象类也没啥区别，继承，override这些也都一样。另外Scala里的单例可以用object来实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TopLevel</span> </span>{     <span class="comment">// abstract class  </span></div><div class="line">  <span class="keyword">def</span> method1(x: Int): Int   <span class="comment">// abstract method  </span></div><div class="line">  <span class="keyword">def</span> method2(x: Int): Int = { ... }  </div><div class="line">}</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Level1</span> <span class="keyword">extends</span> <span class="title">TopLevel</span> </span>{  </div><div class="line">  <span class="keyword">def</span> method1(x: Int): Int = { ... }  </div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> method2(x: Int): Int = { ...} <span class="comment">// TopLevel's method2 needs to be explicitly overridden  </span></div><div class="line">}</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyObject</span> <span class="keyword">extends</span> <span class="title">TopLevel</span> </span>{ ... } <span class="comment">// defines a singleton object. No other instance can be created</span></div></pre></td></tr></table></figure>


<p>另外可以用带有main方法的object来创建一个可执行程序：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Hello</span> </span>{  </div><div class="line">  <span class="keyword">def</span> main(args: Array[String]) = println(<span class="string">"Hello world"</span>)  </div><div class="line">}</div></pre></td></tr></table></figure>


<h3 id="Class_Organization">Class Organization</h3>
<p>Scala的命名空间，import之类也没什么特别之处，各种类可以放在<code>package myPackage</code>里，然后在使用的时候可以<code>import myPackage.myClass</code>或者<code>import myPackage._</code>来import所有内容，也可以选几个import比如<code>import myPackage.{MyClass1, MyClass2}</code>，<code>import myPackage.{MyClass1 =&gt; A}</code>。<br>Scala支持多重继承，这里又引入一个新的关键词<code>trait</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Planar</span> </span>{ ... }</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> <span class="keyword">with</span> <span class="title">Planar</span></span></div></pre></td></tr></table></figure>


<p>所有的classes, objects, traits可以继承最多一个class，但是可以继承任意多个traits（中英混合还考虑单复数，哥哥我真是严谨的一比）。Trait跟Java中的Interface很像，但是trait里是可以有field和具体实现的方法的！<br>另外还有Scala里的type继承关系图，懒得翻译了：</p>
<blockquote>
<p>General object hierarchy:</p>
<ul>
<li><code>scala.Any</code> base type of all types. Has methods <code>hashCode</code> and <code>toString</code> that can be overloaded</li>
<li><code>scala.AnyVal</code> base type of all primitive types. (<code>scala.Double</code>, <code>scala.Float</code>, etc.)</li>
<li><code>scala.AnyRef</code> base type of all reference types. (alias of <code>java.lang.Object</code>, supertype of <code>java.lang.String</code>, <code>scala.List</code>, any user-defined class)</li>
<li><code>scala.Null</code> is a subtype of any <code>scala.AnyRef</code> (<code>null</code> is the only instance of type <code>Null</code>), and <code>scala.Nothing</code> is a subtype of any other type without any instance.</li>
</ul>
</blockquote>
<p>然后老师还提了提fuctions as objects……哥不是函数式编程语言么，但是哥的函数也都是对象……就不怕搞不晕你！</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[<span class="title">A</span>, <span class="title">B</span>] </span>{</div><div class="line">  <span class="keyword">def</span> apply(x: A): B</div><div class="line">}</div></pre></td></tr></table></figure>


<p>于是<code>(x: Int) =&gt; x * x</code>这样的一个函数，就变成了这样一个拥有<code>apply</code>方法的Object：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">{ <span class="class"><span class="keyword">class</span> <span class="title">AnonFun</span> <span class="keyword">extends</span> <span class="title">Function1</span>[<span class="title">Int</span>, <span class="title">Int</span>] </span>{</div><div class="line">  <span class="keyword">def</span> apply(x: Int) = x * x</div><div class="line">  }</div><div class="line">  <span class="keyword">new</span> AnonFun</div><div class="line">}</div></pre></td></tr></table></figure>


<p>怎么样，有种天下大统的感觉了么？这个东西后面还会用到。不过这样的转化会发现Function1这个trait是接受单个参数的，上课时老师提到在Scala里建了很多种这种trait以处理多个参数的情况，目前最多是22个参数……这个感觉不是很优雅啊，像SML中所有函数都只接受一个参数，然后用pattern matching来做具体的“多参数”处理，然后函数直接就可以直接用类似Unix中的pipeline一样做流畅的链式调用，简洁优美啊！</p>
<p>另外老师还表示我大Scala是纯OO语言……比如自然数我们可以这么搞：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Nat</span> </span>{</div><div class="line">  <span class="keyword">def</span> isZero: Boolean</div><div class="line">  <span class="keyword">def</span> predecessor: Nat</div><div class="line">  <span class="keyword">def</span> successor = <span class="keyword">new</span> Succ(<span class="keyword">this</span>)</div><div class="line">  <span class="keyword">def</span> + (that: Nat): Nat</div><div class="line">  <span class="keyword">def</span> - (that: Nat): Nat</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Zero</span> <span class="keyword">extends</span> <span class="title">Nat</span> </span>{</div><div class="line">  <span class="keyword">def</span> isZero = <span class="keyword">true</span></div><div class="line">  <span class="keyword">def</span> predecessor = <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Not a natrual number"</span>)</div><div class="line">  <span class="keyword">def</span> + (that: Nat): Nat = that</div><div class="line">  <span class="keyword">def</span> - (that: Nat): Nat = <span class="keyword">if</span> (that.isZero) Zero <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Not a natrual number"</span>)</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Succ</span><span class="params">(n: Nat)</span> <span class="keyword">extends</span> <span class="title">Nat</span> </span>{</div><div class="line">  <span class="keyword">def</span> isZero = <span class="keyword">false</span></div><div class="line">  <span class="keyword">def</span> predecessor = n</div><div class="line">  <span class="keyword">def</span> + (that: Nat): Nat = <span class="keyword">new</span> Succ(n + that)</div><div class="line">  <span class="keyword">def</span> - (that: Nat): Nat = <span class="keyword">if</span> (that.isZero) <span class="keyword">this</span> <span class="keyword">else</span> n - that.predecessor</div><div class="line">}</div></pre></td></tr></table></figure>


<p>这种既OO又FP的感觉真是太酸爽太劲道了呢……</p>
<h3 id="Polymorphism">Polymorphism</h3>
<p>这个部分是整个课程中比较复杂的部分了……包含subtyping和generics：</p>
<ul>
<li>generics，也就是一个函数或一个类的参数中可以用type parameter，大家应该都挺熟悉比如Java里的<code>public class Entry&lt;K, V&gt;</code>。</li>
<li>subtyping，也就是说一个子类实例可以在要求为其父类实例的地方使用，这个也好理解，因为子类必定是实现了所有父类中的方法的嘛。</li>
</ul>
<p>Scala中的generics：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>[<span class="title">T</span>]<span class="params">(arg1: T)</span> </span>{ ... }</div><div class="line"><span class="keyword">new</span> MyClass[Int](<span class="number">1</span>)</div><div class="line"><span class="keyword">new</span> MyClass(<span class="number">1</span>)   <span class="comment">// the type is being inferred, i.e. determined based on the value arguments</span></div></pre></td></tr></table></figure>


<p>有时候会有需求说我这个Class只接受某种type的子类型，换作动态语言估计得用<code>issubclass</code>之类的方法来写了吧，Java中有<code>&lt;T extends Animal&gt; void addAnimal(T animal)</code>，其他不熟悉……但是我们高大上的Scala却有更加眼花缭乱的方法！这就是type bounds：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> myFct[T &lt;: TopLevel](arg: T): T = { ... } <span class="comment">// T must derive from TopLevel or be TopLevel</span></div><div class="line"><span class="keyword">def</span> myFct[T &gt;: Level1](arg: T): T = { ... }   <span class="comment">// T must be a supertype of Level1</span></div><div class="line"><span class="keyword">def</span> myFct[T &gt;: Level1 &lt;: Top Level](arg: T): T = { ... }</div></pre></td></tr></table></figure>


<p>不得不承认，真是太酷炫了！甚至还能同时指定写成这样：<code>[S &gt;: NonEmpty &lt;: IntSet]</code>。看到这个，是不是有点 <code>&gt; . &lt;</code> 了……</p>
<p>另外一种是Variance，不知道怎么翻译，直接看例子：</p>
<p>比如一个父类为<code>IntSet</code>，其中有两个子类<code>Empty</code>和<code>NonEmpty</code>，已知<code>NonEmpty &lt;: IntSet</code>，那么我们是否可以认为<code>List[NonEmpty] &lt;: List[IntSet]</code>呢？直觉上是可以的，但是仔细一想会有问题，比如以下Java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NonEmpty [] a = <span class="keyword">new</span> NonEmpty []{ <span class="keyword">new</span> NonEmpty (<span class="number">1</span> , Empty , Empty )}</div><div class="line">IntSet [] b = a</div><div class="line">b [<span class="number">0</span>] = Empty</div><div class="line">NonEmpty s = a [<span class="number">0</span>]    <span class="comment">// Boom!</span></div></pre></td></tr></table></figure>


<p>可以看到我们在最后一行把一个Empty类型的变量assign给了NonEmpty类型变量！所以在可变类型中，这种covariant的关系是不存在的！</p>
<p>发现我还没写什么是covariant……</p>
<blockquote>
<p>假设<code>A &lt;: B</code>，<code>C[T]</code>是parameterized type，那么<code>C[A] &lt;: C[B]</code>即为covariant，<code>C[A] &gt;: C[B]</code>为contravariant</p>
</blockquote>
<p>注意！Scala屌炸天的语法又要出现了！</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>[+<span class="title">A</span>] </span>{ ... } <span class="comment">// C is covariant</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>[-<span class="title">A</span>] </span>{ ... } <span class="comment">// C is contravariant</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>[<span class="title">A</span>]  </span>{ ... } <span class="comment">// C is nonvariant</span></div></pre></td></tr></table></figure>


<p>呵呵，世界真奇妙！刚才我们说了，函数也是Object，所以还可以看看函数在输入和输出类型上到底是神马个关系，比如我们有两个函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> A = IntSet =&gt; NonEmpty</div><div class="line"><span class="keyword">type</span> B = NonEmpty =&gt; IntSet</div></pre></td></tr></table></figure>


<p>那他们哪个是爸爸哪个是儿子呢！如果我们有个参数接受类型A，也就是输入一个<code>IntSet</code>输出一个<code>NonEmpty</code>，那我们能用B传进去吗？貌似不行哦，因为A里我还可以接受<code>Empty</code>呢，而B里面可能输出一个<code>Empty</code>又不满足是个<code>NonEmpty</code>，但是反过来就可以了！所以在这里<code>A &lt;: B</code>！这就是函数类型的特殊variance规则，表示如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="title">T</span>, +<span class="title">U</span>] </span>{</div><div class="line">  <span class="keyword">def</span> apply(x: T): U</div><div class="line">} <span class="comment">// Variance check is OK because T is contravariant and U is covariant</span></div></pre></td></tr></table></figure>


<p>而之前那个generic array的继承关系的问题其实正好违反了这个规则：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>[+<span class="title">T</span>] </span>{</div><div class="line">  <span class="keyword">def</span> update(x: T)</div><div class="line">} <span class="comment">// variance checks fails</span></div></pre></td></tr></table></figure>


<p>另一个例子是immutable的<code>List</code>类型，展现了如何正确地通过variance type check：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">List</span>[+<span class="title">T</span>] </span>{</div><div class="line">  <span class="keyword">def</span> isEmpty: Boolean</div><div class="line">  <span class="keyword">def</span> head: T</div><div class="line">  <span class="keyword">def</span> tail: List[T]</div><div class="line">  <span class="keyword">def</span> prepend[U &gt;: T](elem: U): List[U] = <span class="keyword">new</span> Cons(elem, <span class="keyword">this</span>)</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[<span class="title">T</span>]<span class="params">(val head: T, val tail: List[T])</span> <span class="keyword">extends</span> <span class="title">List</span>[<span class="title">T</span>] </span>{</div><div class="line">  <span class="keyword">def</span> isEmpty = <span class="keyword">false</span></div><div class="line">}</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Nil</span> <span class="keyword">extends</span> <span class="title">List</span>[<span class="title">Nothing</span>] </span>{</div><div class="line">  <span class="keyword">def</span> isEmpty: Boolean = <span class="keyword">true</span></div><div class="line">  <span class="keyword">def</span> head: Nothing = <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Nil.head"</span>)</div><div class="line">  <span class="keyword">def</span> tail: Nothing = <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Nil.tail"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>


<p>这里应用了两个关键点：</p>
<ol>
<li><code>Nothing</code>在Scala里是所有type的subtype，所以可以以此搞出一个<code>Nil</code>的单例来！</li>
<li>应用了function的variance规则，在<code>prepend</code>方法里设置了lower bound。然后在一个<code>List[NonEmpty]</code>里prepend一个<code>Empty</code>，就会返回一个<code>List[IntSet]</code>！这个很牛逼了……大家理解一下……从此之后<code>NonEmpty</code>与<code>Empty</code>幸福地生活在了一起，而不用担心其中一个被抓出去调用一个它没有的方法！What a happy ending！</li>
</ol>
<h3 id="Pattern_Matching">Pattern Matching</h3>
<p>这个又是FP中比较常见的decomposing数据结构的方法。这个在Dan的课中也有很大篇幅的介绍，因为这涉及到了OO与FP思想的一些重要的不同。两门课都用了计算表达式这个例子，不过还是Dan讲的比较清晰啊！假设我们有各种类型，基类是Expr，然后一个表达式里可能有Int，有Add，有Negate，有Multiply等类型，然后每个类中都有一些共同的方法比如都可以eval（求值），可以toString来显示表达式等：</p>
<ul>
<li>在OO中一般用的是继承和重载方法，这样在每个类里面实现各自的方法就可以处理不同情况了。所以我们只要在Int，Add等类里实现方法即可，而且要添加一个类也很方便。但是万一我们需要添加一个共同的方法，比如hasZero，那就得在每个类里都写一遍，会比较麻烦。</li>
<li>在FP中用的就是Pattern Matching了，一般是在各个处理方法中去match参数的类型，然后做相应的操作。优劣点跟上面OO的方法正好相反。<br>正是因为OO与FP在decomposing上的不同，所以他们适用的范围也不同，比如OO就很适合GUI编程，因为对于界面元素的操作相对固定，就点击啊拖拽之类的，但是界面元素的种类却相当繁多，所以添加各种子类的case也要多一些。而很多其他的应用比如数据类型没什么变化，但是会增加很多不同的处理方式，那就可以考虑采用FP风格的pattern matching了！下面这个表格摘自Dan的课程，采用OOP时增加一行也就是一种类型是比较容易的，而要增加一种操作就要去修改你所有之前的类的实现了。FP则正好反之。当然OOP中也有解决这些问题的方法比如Visitor模式，就是不如FP那么自然啦。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">Eval</th>
<th style="text-align:center">toString</th>
<th style="text-align:center">hasZero</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td>Add</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td>Negate</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td>Multiply</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>在Scala中的Pattern Matching语法如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(someList: List[T]) <span class="keyword">match</span> {</div><div class="line">  <span class="keyword">case</span> Nil =&gt; ...          <span class="comment">// empty list</span></div><div class="line">  <span class="keyword">case</span> x :: Nil =&gt; ...     <span class="comment">// list with only one element</span></div><div class="line">  <span class="keyword">case</span> List(x) =&gt; ...      <span class="comment">// same as above</span></div><div class="line">  <span class="keyword">case</span> x :: xs =&gt; ...      <span class="comment">// a list with at least one element. x is bound to the head,</span></div><div class="line">                           <span class="comment">// xs to the tail. xs could be Nil or some other list.</span></div><div class="line">  <span class="keyword">case</span> <span class="number">1</span> :: <span class="number">2</span> :: cs =&gt; ... <span class="comment">// lists that starts with 1 and then 2</span></div><div class="line">  <span class="keyword">case</span> (x, y) :: ps =&gt; ... <span class="comment">// a list where the head element is a pair</span></div><div class="line">  <span class="keyword">case</span> _ =&gt; ...            <span class="comment">// default case if none of the above matches</span></div><div class="line">}</div></pre></td></tr></table></figure>


<p>和之前写过的SML比感觉基本没区别……不过Scala跟SML不同之处在于SML里用的是type来表示类型（如果没记错的话……）而在Scala里引入了case class这样就可以不需要调用new myClass就来做匹配了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">MyObject</span> <span class="keyword">extends</span> <span class="title">Somthing</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(a: Int, b: Int)</span></span></div><div class="line">unknownObject <span class="keyword">match</span> {</div><div class="line">  <span class="keyword">case</span> MyObject =&gt; ...</div><div class="line">  <span class="keyword">case</span> MyClass(a, b) =&gt; ...</div><div class="line">}</div></pre></td></tr></table></figure>


<p>case class还有些别的特性比如自动生成了hashCode，equals方法等。具体可以参考<a href="http://www.codecommit.com/blog/scala/case-classes-are-cool" target="_blank" rel="external">这篇文章</a>的详细介绍。</p>
<p>另外SML里有option类型的值，Scala也照单全收。比如如果直接访问<code>Map</code>类型中不存在的key会抛exception，而使用<code>Map.get</code>的方法则默认返回一个<code>Option[T]</code>，可能是<code>Some[T]</code>也可能是<code>None</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> myMap = Map(<span class="string">"a"</span> -&gt; <span class="number">42</span>, <span class="string">"b"</span> -&gt; <span class="number">43</span>)</div><div class="line"><span class="keyword">def</span> getMapValue(s: String): String = {</div><div class="line">  myMap get s <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> Some(nb) =&gt; <span class="string">"Value found: "</span> + nb</div><div class="line">    <span class="keyword">case</span> None =&gt; <span class="string">"No value found"</span></div><div class="line">  }</div><div class="line">}</div><div class="line">getMapValue(<span class="string">"a"</span>)  <span class="comment">// "Value found: 42"</span></div><div class="line">getMapValue(<span class="string">"c"</span>)  <span class="comment">// "No value found"</span></div></pre></td></tr></table></figure>


<p>上面的代码还可以简写成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> getMapValue(s: String): String =</div><div class="line">  myMap.get(s).map(<span class="string">"Value found: "</span> + _).getOrElse(<span class="string">"No value found"</span>)</div></pre></td></tr></table></figure>


<p>恩，反正各种写法都可以，让人开始怀疑人生……另外还有遇到匿名函数时的简写法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> pairs: List[(Char, Int)] = ('a', <span class="number">2</span>) :: ('b', <span class="number">3</span>) :: Nil</div><div class="line"><span class="keyword">val</span> chars: List[Char] = pairs.map(p =&gt; p <span class="keyword">match</span> {</div><div class="line">  <span class="keyword">case</span> (ch, num) =&gt; ch</div><div class="line">})</div></pre></td></tr></table></figure>


<p>=&gt;</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> chars: List[Char] = pairs map {</div><div class="line">  <span class="keyword">case</span> (ch, num) =&gt; ch</div><div class="line">}</div></pre></td></tr></table></figure>


<h3 id="Collections">Collections</h3>
<p>Scala里的各种collections也是大杂烩啊，包含了普通语言中常见的那些Array, List, Map, Set，也有FP中经典的Tuple，Stream……借用一下别人的归纳：</p>
<p><strong>基类</strong></p>
<ul>
<li><code>Iterable</code></li>
<li><code>Seq</code></li>
<li><code>Set</code></li>
<li><code>Map</code></li>
</ul>
<p><strong>不可变类</strong></p>
<ul>
<li><code>List</code> (linked list, provides fast sequential access)</li>
<li><code>Stream</code> (same as List, except that the tail is evaluated only on demand)</li>
<li><code>Vector</code> (array-like type, implemented as tree of blocks, provides fast random access)</li>
<li><code>Range</code> (ordered sequence of integers with equal spacing)</li>
<li><code>String</code> (Java type, implicitly converted to a character sequence, so you can treat every string like a Seq[Char])</li>
<li><code>Map</code> (collection that maps keys to values)</li>
<li><code>Set</code> (collection without duplicate elements)</li>
</ul>
<p><strong>可乱变类</strong></p>
<ul>
<li><code>Array</code> (Scala arrays are native JVM arrays at runtime, therefore they are very performant)</li>
<li><code>scala.collection.mutable.Map</code> and <code>scala.collection.mutable.Set</code> (除非默认的Map，Set性能太差，否则不建议使用)</li>
</ul>
<p>直接从wiki拖个例子列表：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> fruitList = List(<span class="string">"apples"</span>, <span class="string">"oranges"</span>, <span class="string">"pears"</span>)</div><div class="line"><span class="comment">// Alternative syntax for lists</span></div><div class="line"><span class="keyword">val</span> fruit = <span class="string">"apples"</span> :: (<span class="string">"oranges"</span> :: (<span class="string">"pears"</span> :: Nil)) <span class="comment">// parens optional, :: is right-associative</span></div><div class="line">fruit.head   <span class="comment">// "apples"</span></div><div class="line">fruit.tail   <span class="comment">// List("oranges", "pears")</span></div><div class="line"><span class="keyword">val</span> empty = List()</div><div class="line"><span class="keyword">val</span> empty = Nil</div><div class="line"> </div><div class="line"><span class="keyword">val</span> nums = Vector(<span class="string">"louis"</span>, <span class="string">"frank"</span>, <span class="string">"hiromi"</span>)</div><div class="line">nums(<span class="number">1</span>)                     <span class="comment">// element at index 1, returns "frank", complexity O(log(n))</span></div><div class="line">nums.updated(<span class="number">2</span>, <span class="string">"helena"</span>)   <span class="comment">// new vector with a different string at index 2, complexity O(log(n))</span></div><div class="line"> </div><div class="line"><span class="keyword">val</span> fruitSet = Set(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>, <span class="string">"banana"</span>)</div><div class="line">fruitSet.size    <span class="comment">// returns 3: there are no duplicates, only one banana</span></div><div class="line"> </div><div class="line"><span class="keyword">val</span> r: Range = <span class="number">1</span> until <span class="number">5</span> <span class="comment">// 1, 2, 3, 4</span></div><div class="line"><span class="keyword">val</span> s: Range = <span class="number">1</span> to <span class="number">5</span>    <span class="comment">// 1, 2, 3, 4, 5</span></div><div class="line"><span class="number">1</span> to <span class="number">10</span> by <span class="number">3</span>  <span class="comment">// 1, 4, 7, 10</span></div><div class="line"><span class="number">6</span> to <span class="number">1</span> by -<span class="number">2</span>  <span class="comment">// 6, 4, 2</span></div><div class="line"> </div><div class="line"><span class="keyword">val</span> s = (<span class="number">1</span> to <span class="number">6</span>).toSet</div><div class="line">s map (_ + <span class="number">2</span>) <span class="comment">// adds 2 to each element of the set</span></div><div class="line"> </div><div class="line"><span class="keyword">val</span> s = <span class="string">"Hello World"</span></div><div class="line">s filter (c =&gt; c.isUpper) <span class="comment">// returns "HW"; strings can be treated as Seq[Char]</span></div><div class="line"> </div><div class="line"><span class="comment">// Operations on sequences</span></div><div class="line"><span class="keyword">val</span> xs = List(...)</div><div class="line">xs.length   <span class="comment">// number of elements, complexity O(n)</span></div><div class="line">xs.last     <span class="comment">// last element (exception if xs is empty), complexity O(n)</span></div><div class="line">xs.init     <span class="comment">// all elements of xs but the last (exception if xs is empty), complexity O(n)</span></div><div class="line">xs take n   <span class="comment">// first n elements of xs</span></div><div class="line">xs drop n   <span class="comment">// the rest of the collection after taking n elements</span></div><div class="line">xs(n)       <span class="comment">// the nth element of xs, complexity O(n)</span></div><div class="line">xs ++ ys    <span class="comment">// concatenation, complexity O(n)</span></div><div class="line">xs.reverse  <span class="comment">// reverse the order, complexity O(n)</span></div><div class="line">xs updated(n, x)  <span class="comment">// same list than xs, except at index n where it contains x, complexity O(n)</span></div><div class="line">xs indexOf x      <span class="comment">// the index of the first element equal to x (-1 otherwise)</span></div><div class="line">xs contains x     <span class="comment">// same as xs indexOf x &gt;= 0</span></div><div class="line">xs filter p       <span class="comment">// returns a list of the elements that satisfy the predicate p</span></div><div class="line">xs filterNot p    <span class="comment">// filter with negated p </span></div><div class="line">xs partition p    <span class="comment">// same as (xs filter p, xs filterNot p)</span></div><div class="line">xs takeWhile p    <span class="comment">// the longest prefix consisting of elements that satisfy p</span></div><div class="line">xs dropWhile p    <span class="comment">// the remainder of the list after any leading element satisfying p have been removed</span></div><div class="line">xs span p         <span class="comment">// same as (xs takeWhile p, xs dropWhile p)</span></div><div class="line"> </div><div class="line">List(x1, ..., xn) reduceLeft op    <span class="comment">// (...(x1 op x2) op x3) op ...) op xn</span></div><div class="line">List(x1, ..., xn).foldLeft(z)(op)  <span class="comment">// (...( z op x1) op x2) op ...) op xn</span></div><div class="line">List(x1, ..., xn) reduceRight op   <span class="comment">// x1 op (... (x{n-1} op xn) ...)</span></div><div class="line">List(x1, ..., xn).foldRight(z)(op) <span class="comment">// x1 op (... (    xn op  z) ...)</span></div><div class="line"> </div><div class="line">xs exists p    <span class="comment">// true if there is at least one element for which predicate p is true</span></div><div class="line">xs forall p    <span class="comment">// true if p(x) is true for all elements</span></div><div class="line">xs zip ys      <span class="comment">// returns a list of pairs which groups elements with same index together</span></div><div class="line">xs unzip       <span class="comment">// opposite of zip: returns a pair of two lists</span></div><div class="line">xs.flatMap f   <span class="comment">// applies the function to all elements and concatenates the result</span></div><div class="line">xs.sum         <span class="comment">// sum of elements of the numeric collection</span></div><div class="line">xs.product     <span class="comment">// product of elements of the numeric collection</span></div><div class="line">xs.max         <span class="comment">// maximum of collection</span></div><div class="line">xs.min         <span class="comment">// minimum of collection</span></div><div class="line">xs.flatten     <span class="comment">// flattens a collection of collection into a single-level collection</span></div><div class="line">xs groupBy f   <span class="comment">// returns a map which points to a list of elements</span></div><div class="line">xs distinct    <span class="comment">// sequence of distinct entries (removes duplicates)</span></div><div class="line"> </div><div class="line">x +: xs  <span class="comment">// creates a new collection with leading element x</span></div><div class="line">xs :+ x  <span class="comment">// creates a new collection with trailing element x</span></div><div class="line"> </div><div class="line"><span class="comment">// Operations on maps</span></div><div class="line"><span class="keyword">val</span> myMap = Map(<span class="string">"I"</span> -&gt; <span class="number">1</span>, <span class="string">"V"</span> -&gt; <span class="number">5</span>, <span class="string">"X"</span> -&gt; <span class="number">10</span>)  <span class="comment">// create a map</span></div><div class="line">myMap(<span class="string">"I"</span>)      <span class="comment">// =&gt; 1  </span></div><div class="line">myMap(<span class="string">"A"</span>)      <span class="comment">// =&gt; java.util.NoSuchElementException  </span></div><div class="line">myMap get <span class="string">"A"</span>   <span class="comment">// =&gt; None </span></div><div class="line">myMap get <span class="string">"I"</span>   <span class="comment">// =&gt; Some(1)</span></div><div class="line">myMap.updated(<span class="string">"V"</span>, <span class="number">15</span>)  <span class="comment">// returns a new map where "V" maps to 15 (entry is updated)</span></div><div class="line">                        <span class="comment">// if the key ("V" here) does not exist, a new entry is added</span></div><div class="line"> </div><div class="line"><span class="comment">// Operations on Streams</span></div><div class="line"><span class="keyword">val</span> xs = Stream(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> xs = Stream.cons(<span class="number">1</span>, Stream.cons(<span class="number">2</span>, Stream.cons(<span class="number">3</span>, Stream.empty))) <span class="comment">// same as above</span></div><div class="line">(<span class="number">1</span> to <span class="number">1000</span>).toStream <span class="comment">// =&gt; Stream(1, ?)</span></div><div class="line">x #:: xs <span class="comment">// Same as Stream.cons(x, xs)</span></div><div class="line">         <span class="comment">// In the Stream's cons operator, the second parameter (the tail)</span></div><div class="line">         <span class="comment">// is defined as a "call by name" parameter.</span></div><div class="line">         <span class="comment">// Note that x::xs always produces a List</span></div><div class="line"> </div><div class="line"><span class="keyword">val</span> pair = (<span class="string">"answer"</span>, <span class="number">42</span>)   <span class="comment">// type: (String, Int)</span></div><div class="line"><span class="keyword">val</span> (label, value) = pair   <span class="comment">// label = "answer", value = 42  </span></div><div class="line">pair._1 <span class="comment">// "answer"  </span></div><div class="line">pair._2 <span class="comment">// 42</span></div></pre></td></tr></table></figure>


<p>这下大家满足了吧！某一周的作业就是用这些方法来写一个霍夫曼树编码，相当精炼的感觉！重点来几个语法糖酷炫一下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sum(xs: List[Int]): Int = xs <span class="keyword">match</span> {</div><div class="line">  <span class="keyword">case</span> Nil =&gt; <span class="number">0</span></div><div class="line">  <span class="keyword">case</span> y :: ys =&gt; y + sum(ys)</div><div class="line">}</div></pre></td></tr></table></figure>


<p>这是最初版本，然后我们用上<code>reduceLeft</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sum(xs: List[Int]) = (<span class="number">0</span> :: xs) reduceLeft ((x, y) =&gt; x + y)</div></pre></td></tr></table></figure>


<p>恩，怎么有个<code>0 :: xs</code>，不优雅！换<code>foldLeft</code>，顺便把那个匿名函数也搞成<strong>颜文字</strong>把！</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sum(xs: List[Int]) = (xs foldLeft <span class="number">0</span>) (_ + _)</div></pre></td></tr></table></figure>


<p>简单吗？还可以更犀利！</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sum(xs: List[Int]) = (<span class="number">0</span>/:xs) (_ + _)</div></pre></td></tr></table></figure>


<p>这样是不是不太好啊！</p>
<h3 id="Ordering">Ordering</h3>
<p>写了这么多有点累了，接下来写的简洁点，如果不够以后再补充。<code>Ordering</code>主要是实现了一些比较函数如<code>lt()</code>，<code>gt()</code>等，我们可以利用它（大多数还是上面的collection的操作）来写个merge sort：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math.Ordering  </div><div class="line"> </div><div class="line"><span class="keyword">def</span> msort[T](xs: List[T])(implicit ord: Ordering[T]): List[T] = {</div><div class="line">  <span class="keyword">val</span> n = xs.length / <span class="number">2</span></div><div class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) xs</div><div class="line">  <span class="keyword">else</span> {</div><div class="line">    <span class="keyword">def</span> merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) <span class="keyword">match</span> {</div><div class="line">      <span class="keyword">case</span> (Nil, ys) =&gt; ys</div><div class="line">      <span class="keyword">case</span> (xs, Nil) =&gt; xs</div><div class="line">      <span class="keyword">case</span> (x :: xs1, y :: ys1) =&gt; {</div><div class="line">        <span class="keyword">if</span> (ord.lt(x, y)) x :: merge(xs1, ys)</div><div class="line">        <span class="keyword">else</span> y :: merge(xs, ys1)</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keyword">val</span> (fst, snd) = xs splitAt n</div><div class="line">    merge(msort(fst), msort(snd))</div><div class="line">  }</div><div class="line">}</div><div class="line">msort(fruits)(Ordering.String)</div><div class="line">msort(fruits)   <span class="comment">// the compiler figures out the right ordering</span></div></pre></td></tr></table></figure>


<p>这样就可以自动对数字或者字符排序了！当然Scala其实自己也有很多排序函数，比如可以这样对一个Map根据其Key的长度来排序：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myMap.toSeq.sortBy(_._1.length).reverse</div></pre></td></tr></table></figure>


<h3 id="For-Comprehensions">For-Comprehensions</h3>
<p>Scala的for语句还是很有特色的，大致的形式就是<code>for (s) yield e</code>其中<code>s</code>中是生成器（<code>p &lt;- e</code>）和过滤器（<code>if cond</code>），如果有多个生成器就相当于多重循环了！最后的<code>e</code>是要返回的内容，然后可以把整个返回的内容作为一个collection再应用上面列举的那些方法做各种处理。示范代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// list all combinations of numbers x and y where x is drawn from</span></div><div class="line"><span class="comment">// 1 to M and y is drawn from 1 to N</span></div><div class="line"><span class="keyword">for</span> (x &lt;- <span class="number">1</span> to M; y &lt;- <span class="number">1</span> to N)</div><div class="line">  <span class="keyword">yield</span> (x,y)</div></pre></td></tr></table></figure>


<p>这还不够，课程中还提到for语句可以完全转换成另一种形式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span> to M) flatMap (x =&gt; (<span class="number">1</span> to N) map (y =&gt; (x, y)))</div></pre></td></tr></table></figure>


<p>详细的规则如下：</p>
<ul>
<li><code>for (x &lt;- e1) yield e2</code> is translated to <code>e1.map(x =&gt; e2)</code></li>
<li><code>for (x &lt;- e1 if f; s) yield e2</code> is translated to <code>for (x &lt;- e1.withFilter(x =&gt; f); s) yield e2</code></li>
<li><code>for (x &lt;- e1; y &lt;- e2; s) yield e3</code> is translated to <code>e1.flatMap(x =&gt; for (y &lt;- e2; s) yield e3)</code></li>
</ul>
<p>再来个应用例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> {</div><div class="line">  i &lt;- <span class="number">1</span> until n</div><div class="line">  j &lt;- <span class="number">1</span> until i</div><div class="line">  <span class="keyword">if</span> isPrime(i + j)</div><div class="line">} <span class="keyword">yield</span> (i, j)</div></pre></td></tr></table></figure>


<p>就可以直接转化成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span> until n) flatMap (i =&gt; (<span class="number">1</span> until i) withFilter (j =&gt; isPrime(i+j))</div><div class="line">  map (j =&gt; (i, j)))</div></pre></td></tr></table></figure>


<p>也就是说如果你在类中定义了<code>flatMap</code>，<code>withFilter</code>，<code>map</code>就可以自由地对你的类型使用for语句啦！(类似实现<code>Iterator</code>？)</p>
<p>课上还用它写了个实际的8皇后问题：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> isSafe(col: Int, queens: List[Int]): Boolean = {</div><div class="line">  <span class="keyword">val</span> row = queens.length</div><div class="line">  <span class="keyword">val</span> queensWithRow = (row - <span class="number">1</span> to <span class="number">0</span> by -<span class="number">1</span>) zip queens</div><div class="line">  queensWithRow forall {</div><div class="line">    <span class="keyword">case</span> (r, c) =&gt; col != c && math.abs(col - c) != row - r</div><div class="line">  }</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">def</span> queens(n: Int): Set[List[Int]] = {</div><div class="line">  <span class="keyword">def</span> placeQueens(k: Int): Set[List[Int]] = {</div><div class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) Set(List())</div><div class="line">    <span class="keyword">else</span> <span class="keyword">for</span> {</div><div class="line">      queens &lt;- placeQueens(k - <span class="number">1</span>)</div><div class="line">      col &lt;- <span class="number">0</span> until n</div><div class="line">      <span class="keyword">if</span> isSafe(col, queens)</div><div class="line">    } <span class="keyword">yield</span> col :: queens</div><div class="line">  }</div><div class="line">  placeQueens(n)</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">def</span> show(queens: List[Int]) = {</div><div class="line">  <span class="keyword">val</span> lines = {</div><div class="line">    <span class="keyword">for</span> (col &lt;- queens.reverse)</div><div class="line">    <span class="keyword">yield</span> Vector.fill(queens.length)(<span class="string">"* "</span>).updated(col, <span class="string">"X "</span>).mkString</div><div class="line">  }</div><div class="line">  <span class="string">"\n"</span> + (lines mkString <span class="string">"\n"</span>)</div><div class="line">}</div><div class="line">(queens(<span class="number">8</span>) take <span class="number">1</span> map show) mkString <span class="string">"\n"</span></div></pre></td></tr></table></figure>


<h3 id="Stream_and_Lazy_Evaluation">Stream and Lazy Evaluation</h3>
<p>Stream也是在collections里的一种，但它性质有些特别，所以就单独拿出来看一下。Stream基本可以当成一个惰性求值的list来看，课上给了一个这样的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((<span class="number">1000</span> to <span class="number">10000</span>) filter isPrime)(<span class="number">1</span>)</div></pre></td></tr></table></figure>


<p>这行代码会寻找在1000到10000范围内的质数，然后取第2个。但虽然我们只需要取2个质数，程序还是会先把所有在范围内的质数取出来再取第二个，浪费了很多无用的计算。这时候就可以利用我们的stream来优化性能了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((<span class="number">1000</span> to <span class="number">10000</span>).toStream filter isPrime)(<span class="number">1</span>)</div></pre></td></tr></table></figure>


<p>还可以生成无限长度的序列并进行计算：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> from(n: Int): Stream[Int] = n #:: from(n+<span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> nats = from(<span class="number">0</span>)</div><div class="line"><span class="keyword">def</span> sieve(s: Stream[Int]): Stream[Int] =</div><div class="line">  s.head #:: sieve(s.tail filter (_ % s.head != <span class="number">0</span>))</div><div class="line"><span class="keyword">val</span> primes = sieve(from(<span class="number">2</span>))</div><div class="line">primes.take(<span class="number">10</span>).toList</div></pre></td></tr></table></figure>


<p>这里首先是生成一个自然数的stream，然后sieve函数取出这个stream的头，把后面所有能被它整除的数都过滤掉，这样就可以生成一个质数的stream，看起来挺违反直觉的，不过课上有详细的展开，我们这边就拿个最简单的<code>take(1)</code>来看下吧：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(from(<span class="number">2</span>).head #:: sieve(from(<span class="number">2</span>).tail filter (_ % from(<span class="number">2</span>).head != <span class="number">0</span>))).take(<span class="number">1</span>)</div></pre></td></tr></table></figure>


<p>然后由于是个stream，<code>#::</code>操作符后面那部分是惰性求值的，这里跑<code>take(1)</code>所以直接拿<code>from(2).head</code>就行了，后面的都不会被求值，最终输出2。</p>
<p>Racket跟Scala一样是call-by-value的，所以函数中的参数也必须先求值。但Racket里也可以生成stream，用的是一种叫<code>thunk</code>的技术！大致就是把函数原来的参数变成一个匿名函数，只有在call它的时候才会去求值，然后同理就可以用递归构造出一个无穷的stream来啦！</p>
<p>另外Scala里的lazy evaluation还可以用来做mutual recursion，来解释一些<strong>哲学</strong>问题：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> <span class="params">(e: =&gt; Egg)</span> </span>{</div><div class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> offspring = e</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> <span class="params">(c: =&gt; Chicken)</span> </span>{</div><div class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> mother = c</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> chicken: Chicken = <span class="keyword">new</span> Chicken(egg)</div><div class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> egg: Egg         = <span class="keyword">new</span> Egg(chicken)</div></pre></td></tr></table></figure>


<h2 id="作业">作业</h2>
<p>最后讲讲这门课的作业吧！总共7周的作业，选几个有趣的来看看。</p>
<h3 id="FuncSet">FuncSet</h3>
<p>这个作业是用函数方式来表示一个集合（Set）。我们传统概念中的集合，自然而然会联想到数组啊链表啊这样的数据结构，然后在此基础上去实现集合的各种接口。但是在这个作业里，我们要用函数来表示一个集合，用操作集合的规范来定义这个集合。这么说有点抽象，可以直接看代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Set = Int =&gt; Boolean</div><div class="line"><span class="keyword">def</span> contains(s: Set, elem: Int): Boolean = s(elem)</div><div class="line"><span class="keyword">def</span> singletonSet(elem: Int): Set = (i: Int) =&gt; i == elem</div><div class="line"><span class="keyword">def</span> union(s: Set, t: Set): Set = (i: Int) =&gt; s(i) || t(i)</div><div class="line"><span class="keyword">def</span> intersect(s: Set, t: Set): Set = (i: Int) =&gt; s(i) && t(i)</div><div class="line"><span class="keyword">def</span> diff(s: Set, t: Set): Set = (i: Int) =&gt; s(i) && !t(i)</div><div class="line"><span class="keyword">def</span> filter(s: Set, p: Int =&gt; Boolean): Set = (i: Int) =&gt; s(i) && p(i)</div><div class="line"><span class="keyword">val</span> bound = <span class="number">1000</span></div><div class="line"><span class="keyword">def</span> forall(s: Set, p: Int =&gt; Boolean): Boolean = {</div><div class="line">  <span class="keyword">def</span> iter(a: Int): Boolean = {</div><div class="line">    <span class="keyword">if</span> (a &gt; bound) <span class="keyword">true</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s(a) && !p(a)) <span class="keyword">false</span></div><div class="line">    <span class="keyword">else</span> iter(a + <span class="number">1</span>)</div><div class="line">  }</div><div class="line">  iter(-bound)</div><div class="line">}</div><div class="line"><span class="keyword">def</span> exists(s: Set, p: Int =&gt; Boolean): Boolean = !forall(s, !p(_))</div><div class="line"><span class="keyword">def</span> map(s: Set, f: Int =&gt; Int): Set = (i: Int) =&gt; exists(s, f(_) == i)</div></pre></td></tr></table></figure>


<p>直接用了<code>(Int =&gt; Boolean)</code>的函数来表示一个集合，然后各种操作也都是去改变这个函数的行为。不过用这种方式没法做出一个迭代器来，要改成线性表形式才行。当然线性表形式结构也是可以用函数式方法来表示的。</p>
<h3 id="Huffman_Code">Huffman Code</h3>
<p>用Scala来实现Huffman编码，与实际问题结合更能体验函数式编程的表达方式。给出的框架代码把问题分割地很好，只要一块一块实现下来就行，每个函数基本上都在十行以内，逻辑也很顺畅明了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Huffman code tree的类定义</span></div><div class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeTree</span></span></div><div class="line">  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Fork</span><span class="params">(left: CodeTree, right: CodeTree, chars: List[Char], weight: Int)</span> <span class="keyword">extends</span> <span class="title">CodeTree</span></span></div><div class="line">  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(char: Char, weight: Int)</span> <span class="keyword">extends</span> <span class="title">CodeTree</span></span></div><div class="line"> </div><div class="line"><span class="comment">// 统计char的出现次数</span></div><div class="line">  <span class="keyword">def</span> times(chars: List[Char]): List[(Char, Int)] = {</div><div class="line">    <span class="keyword">def</span> incr(acc: Map[Char, Int], c: Char) = {</div><div class="line">      <span class="keyword">val</span> count = (acc get c).getOrElse(<span class="number">0</span>) + <span class="number">1</span></div><div class="line">      acc + ((c, count))</div><div class="line">    }</div><div class="line">    (Map[Char, Int]() /: chars)(incr).toList</div><div class="line">  }</div><div class="line"> </div><div class="line"><span class="comment">// 生成叶子节点的list，每个char出现的次数即为节点的权重</span></div><div class="line">  <span class="keyword">def</span> makeOrderedLeafList(freqs: List[(Char, Int)]): List[Leaf] = freqs.sortBy(_._2) map((f) =&gt; Leaf(f._1, f._2))</div><div class="line"> </div><div class="line"><span class="comment">// 把上面生成的叶子节点的list缓缓地merge成一整棵树！</span></div><div class="line"><span class="comment">// Huffman code tree中出现频数最小的char应该在树中的层越深，所以在merge过程中保持排序</span></div><div class="line">  <span class="keyword">def</span> combine(trees: List[CodeTree]): List[CodeTree] = trees <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> left :: right :: cs =&gt; (makeCodeTree(left, right) :: cs).sortBy(weight(_))</div><div class="line">    <span class="keyword">case</span> _ =&gt; trees</div><div class="line">  }</div><div class="line"> </div><div class="line">  <span class="keyword">def</span> until(isSingleton: List[CodeTree] =&gt; Boolean, combineTree: List[CodeTree] =&gt; List[CodeTree])</div><div class="line">           (listOfTree: List[CodeTree]): CodeTree = {</div><div class="line">    <span class="keyword">if</span>(isSingleton(listOfTree)) listOfTree.head</div><div class="line">    <span class="keyword">else</span> until(isSingleton, combineTree)(combineTree(listOfTree))</div><div class="line">  }</div><div class="line"> </div><div class="line">  <span class="keyword">def</span> createCodeTree(chars: List[Char]): CodeTree = {</div><div class="line">    until(singleton, combine)(makeOrderedLeafList(times(chars)))</div><div class="line">  }</div><div class="line"> </div><div class="line"><span class="comment">// Decode - 根据生成的树来decode，走到leaf就表示成功decode了一个char</span></div><div class="line">  <span class="keyword">def</span> decode(tree: CodeTree, bits: List[Bit]): List[Char] = {</div><div class="line">    <span class="keyword">def</span> travel(remainingTree: CodeTree, remainingBits: List[Bit]): List[Char] = remainingTree <span class="keyword">match</span> {</div><div class="line">      <span class="keyword">case</span> Leaf(c, _) =&gt; {</div><div class="line">        <span class="keyword">if</span> (remainingBits.isEmpty) List(c)</div><div class="line">        <span class="keyword">else</span> c :: travel(tree, remainingBits)</div><div class="line">      }</div><div class="line">      <span class="keyword">case</span> Fork(left, right, _, _) =&gt; {</div><div class="line">        <span class="keyword">if</span> (remainingBits.head == <span class="number">0</span>) travel(left, remainingBits.tail)</div><div class="line">        <span class="keyword">else</span> travel(right, remainingBits.tail)</div><div class="line">      }</div><div class="line">    }</div><div class="line">    travel(tree, bits)</div><div class="line">  }</div><div class="line"> </div><div class="line"><span class="comment">// Encode - 同理，根据生成的树来encode</span></div><div class="line">  <span class="keyword">def</span> encode(tree: CodeTree)(text: List[Char]): List[Bit] = {</div><div class="line">    <span class="keyword">def</span> lookup(tree: CodeTree)(char: Char): List[Bit] = tree <span class="keyword">match</span> {</div><div class="line">      <span class="keyword">case</span> Leaf(_, _) =&gt; List[Bit]()</div><div class="line">      <span class="keyword">case</span> Fork(left, right, _, _) =&gt; {</div><div class="line">        <span class="keyword">if</span> (chars(left).contains(char)) <span class="number">0</span> :: lookup(left)(char)</div><div class="line">        <span class="keyword">else</span> <span class="number">1</span>::lookup(right)(char)</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (text.length == <span class="number">0</span>) List[Bit]()</div><div class="line">    <span class="keyword">else</span> lookup(tree)(text.head) ::: encode(tree)(text.tail)</div><div class="line">  }</div><div class="line"> </div><div class="line"><span class="comment">// 已经这么长了后面的就不贴了吧，还可以先把codeTree转成一个Map来做快速encode，做做性能优化</span></div><div class="line">...</div></pre></td></tr></table></figure>


<h3 id="Bloxorz">Bloxorz</h3>
<p>这是最后一次作业，用stream来解决一个游戏的解法问题。就那么几行代码，就写出了一个bfs……</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> from(initial: Stream[(Block, List[Move])],</div><div class="line">         explored: Set[Block]): Stream[(Block, List[Move])] = {</div><div class="line">  <span class="keyword">if</span> (initial.isEmpty) Stream.Empty</div><div class="line">  <span class="keyword">else</span> {</div><div class="line">    <span class="keyword">val</span> more = <span class="keyword">for</span> {</div><div class="line">      (block, moves) &lt;- initial</div><div class="line">      newNeighbor &lt;- newNeighborsOnly(neighborsWithHistory(block, moves), explored)</div><div class="line">    } <span class="keyword">yield</span> newNeighbor</div><div class="line">    initial ++ from(more, explored ++ (more map (x =&gt; x._1)))</div><div class="line">  }</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> pathsFromStart: Stream[(Block, List[Move])] = from(Stream.cons((startBlock, List()), Stream.Empty), Set(startBlock))</div><div class="line"> </div><div class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> pathsToGoal: Stream[(Block, List[Move])] = pathsFromStart filter (p =&gt; done(p._1))</div><div class="line"> </div><div class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> solution: List[Move] = {</div><div class="line">  <span class="keyword">if</span> (pathsToGoal.isEmpty) List()</div><div class="line">  <span class="keyword">else</span> pathsToGoal.head._2</div><div class="line">}</div></pre></td></tr></table></figure>


<p>当然真实的游戏还有机关什么的会更复杂点……应该很多人都玩过吧，大家可以在<a href="http://www.coolmath-games.com/0-bloxorz/" target="_blank" rel="external">这里</a>重温一下。</p>
<h2 id="终于写完了">终于写完了</h2>
<p>今天真是有意义的一天！</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/FP/">FP</a><a href="/tags/Scala/">Scala</a><a href="/tags/Coursera/">Coursera</a>
  </div>

</div>


<div class="article-share" id="share">

  <div data-url="http://zijie0.github.io/2014/06/13/Learning-Scala/" data-title="Learning Scala | Tada!" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/07/24/Python-Algorithms---Knapsack-Problem/" title="Python Algorithms - Knapsack Problem">
  <strong>上一篇：</strong><br/>
  <span>
  Python Algorithms - Knapsack Problem</span>
</a>
</div>


<div class="next">
<a href="/2014/06/05/linux-scsi-fault-injection/"  title="Linux SCSI Fault Injection">
 <strong>下一篇：</strong><br/> 
 <span>Linux SCSI Fault Injection
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#寒暄"><span class="toc-number">1.</span> <span class="toc-text">寒暄</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正文"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#环境准备"><span class="toc-number">2.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REPL"><span class="toc-number">2.2.</span> <span class="toc-text">REPL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Evaluation_Rules"><span class="toc-number">2.3.</span> <span class="toc-text">Evaluation Rules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归与尾递归"><span class="toc-number">2.4.</span> <span class="toc-text">递归与尾递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#High_order_functions"><span class="toc-number">2.5.</span> <span class="toc-text">High order functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Currying"><span class="toc-number">2.6.</span> <span class="toc-text">Currying</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Classes"><span class="toc-number">2.7.</span> <span class="toc-text">Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class_Hierarchies"><span class="toc-number">2.8.</span> <span class="toc-text">Class Hierarchies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class_Organization"><span class="toc-number">2.9.</span> <span class="toc-text">Class Organization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Polymorphism"><span class="toc-number">2.10.</span> <span class="toc-text">Polymorphism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pattern_Matching"><span class="toc-number">2.11.</span> <span class="toc-text">Pattern Matching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections"><span class="toc-number">2.12.</span> <span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ordering"><span class="toc-number">2.13.</span> <span class="toc-text">Ordering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#For-Comprehensions"><span class="toc-number">2.14.</span> <span class="toc-text">For-Comprehensions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream_and_Lazy_Evaluation"><span class="toc-number">2.15.</span> <span class="toc-text">Stream and Lazy Evaluation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作业"><span class="toc-number">3.</span> <span class="toc-text">作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FuncSet"><span class="toc-number">3.1.</span> <span class="toc-text">FuncSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Huffman_Code"><span class="toc-number">3.2.</span> <span class="toc-text">Huffman Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bloxorz"><span class="toc-number">3.3.</span> <span class="toc-text">Bloxorz</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终于写完了"><span class="toc-number">4.</span> <span class="toc-text">终于写完了</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Coursera/" title="Coursera">Coursera<sup>4</sup></a></li>
		
			<li><a href="/tags/Python/" title="Python">Python<sup>3</sup></a></li>
		
			<li><a href="/tags/Linux/" title="Linux">Linux<sup>2</sup></a></li>
		
			<li><a href="/tags/Algorithms/" title="Algorithms">Algorithms<sup>2</sup></a></li>
		
			<li><a href="/tags/Scala/" title="Scala">Scala<sup>1</sup></a></li>
		
			<li><a href="/tags/Assembly/" title="Assembly">Assembly<sup>1</sup></a></li>
		
			<li><a href="/tags/gdb/" title="gdb">gdb<sup>1</sup></a></li>
		
			<li><a href="/tags/Performance/" title="Performance">Performance<sup>1</sup></a></li>
		
			<li><a href="/tags/SystemTap/" title="SystemTap">SystemTap<sup>1</sup></a></li>
		
			<li><a href="/tags/book/" title="book">book<sup>1</sup></a></li>
		
			<li><a href="/tags/FP/" title="FP">FP<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
      <li><a href="http://csrd.aliapp.com/" target="_blank" title="Ali">阿里核心系统团队博客</a></li>
      <li><a href="http://kernel.taobao.org/index.php" target="_blank" title="AliKernel">阿里内核组</a></li>
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/010bytes" target="_blank" class="icon-weibo" title="weibo"></a>
		
		
		<a href="https://github.com/zijie0" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		<a href="https://www.douban.com/people/drinkdrink" target="_blank" class="icon-douban" title="豆瓣"></a>
		
		
		
		<a href="mailto:myoilbox@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Pacman">Jacman</a> © 2015 
		
		<a href="http://zijie0.github.io/about" target="_blank" title="Zijie0">Zijie0</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"zijie0"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>




<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-51424600-1', 'zijie0.github.io');  
ga('send', 'pageview');
</script>




<div id="totop">
<a title="Back to Top"><img src="/img/scrollup.png"/></a>
</div>

<script src="/js/totop.js"></script>




  </body>
</html>
